Halo teman-teman, sekarang kita akan melanjutkan dengan skenario performance testing yang lebih kompleks yaitu testing untuk proses login bersamaan. Skenario ini sangat penting karena proses login merupakan salah satu fungsi kritis dalam sistem yang seringkali menjadi bottleneck ketika banyak pengguna mengakses secara bersamaan. Kita akan menguji bagaimana sistem menangani multiple user yang melakukan login pada waktu yang hampir bersamaan ke website https://kf-lab.sahabat.belajar.com dengan kredensial yang telah disediakan.

Dalam skenario real-world, proses login biasanya melibatkan pertukaran data yang lebih kompleks dibandingkan dengan sekedar mengakses halaman statis. Sistem perlu melakukan validasi kredensial, membuat session, meng-generate token authentication, dan redirect user ke halaman yang sesuai. Semua proses ini membutuhkan resources yang signifikan dari server, database, dan infrastruktur pendukung lainnya. Oleh karena itu, testing pada fungsi login menjadi sangat crucial untuk memastikan pengalaman pengguna yang smooth bahkan pada saat peak traffic.

## File Structure dan Setup

Kita akan membuat file dengan nama `login-load-test.js` yang secara khusus difokuskan untuk testing proses authentication. Penamaan file ini jelas mencerminkan tujuan testing dan memudahkan identifikasi di kemudian hari.

## Source Code Lengkap

```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const loginFailRate = new Rate('login_failed');

export const options = {
  stages: [
    { duration: '1m', target: 10 },   // Ramp-up bertahap
    { duration: '3m', target: 20 },   // Stabil di 20 VU
    { duration: '1m', target: 0 },    // Ramp-down
  ],
  thresholds: {
    http_req_failed: ['rate<0.03'],           // Max 3% failed requests
    http_req_duration: ['p(95)<4000'],        // 95% requests < 4 detik
    login_failed: ['rate<0.02'],              // Max 2% login gagal
    http_req_waiting: ['p(95)<3000'],         // 95% waiting time < 3 detik
  },
};

export default function () {
  const baseUrl = 'https://kf-lab.sahabat.belajar.com';
  const loginUrl = `${baseUrl}/login`;
  const dashboardUrl = `${baseUrl}/dashboard/index.php`;
  
  const credentials = {
    username: 'rozak',
    password: '12345678',
  };
  
  const params = {
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'User-Agent': 'Mozilla/5.0 (K6 Performance Test)',
    },
    redirects: 0,
    timeout: '30s',
  };
  
  const loginResponse = http.post(loginUrl, credentials, params);
  
  const loginSuccess = check(loginResponse, {
    'login status is 200 or 302': (r) => r.status === 200 || r.status === 302,
    'login response has session data': (r) => r.headers['Set-Cookie'] !== undefined,
    'login redirects to dashboard': (r) => {
      if (r.status === 302) {
        return r.headers.Location.includes('dashboard');
      }
      return true;
    },
  });
  
  loginFailRate.add(!loginSuccess);
  
  if (loginSuccess) {
    const dashboardResponse = http.get(dashboardUrl, {
      headers: {
        'Cookie': loginResponse.headers['Set-Cookie'],
        'User-Agent': 'Mozilla/5.0 (K6 Performance Test)',
      },
    });
    
    check(dashboardResponse, {
      'dashboard accessible after login': (r) => r.status === 200,
      'dashboard contains user data': (r) => r.body.includes('dashboard') || r.body.includes('rozak'),
      'dashboard page loaded completely': (r) => r.body.length > 1000,
    });
  }
  
  sleep(Math.random() * 2 + 1);
}
```

## Penjelasan Detail Step by Step

Mari kita analisis setiap bagian dari kode performance test untuk login ini secara mendetail. Dimulai dari bagian import, kita mengimpor module http untuk melakukan HTTP requests, check untuk validasi response, sleep untuk simulasi jeda, dan Rate untuk membuat custom metric yang akan mengukur rate kegagalan login. Custom metric ini penting karena kita ingin memonitor secara spesifik berapa banyak percobaan login yang gagal, terlepas dari apakah HTTP request itu sendiri berhasil atau tidak.

Pada bagian options, kita mendefinisikan staging pattern yang sedikit berbeda dari test sebelumnya. Kita melakukan ramp-up yang lebih cepat dalam 1 menit ke 10 virtual user, kemudian menstabilkan di 20 virtual user selama 3 menit, dan akhirnya ramp-down dalam 1 menit. Pola ini mensimulasikan scenario dimana tiba-tiba ada 20 user yang mencoba login dalam waktu bersamaan. Threshold yang kita tetapkan lebih ketat dibanding test sebelumnya karena proses login diharapkan memiliki reliability yang tinggi. Kita menetapkan maksimal 3% failed requests, 95% requests harus selesai dalam 4 detik, maksimal 2% login gagal, dan 95% waiting time harus kurang dari 3 detik.

Dalam fungsi default, kita pertama-tama mendefinisikan URL yang akan digunakan. Terdapat base URL, login URL untuk endpoint authentication, dan dashboard URL sebagai target setelah login berhasil. Kemudian kita menyimpan credentials yang akan digunakan untuk login dalam bentuk object. Parameter request juga dikonfigurasi dengan headers yang appropriate untuk form submission, termasuk Content-Type application/x-www-form-urlencoded yang typical untuk form login traditional. Kita juga men-set redirects ke 0 untuk memonitor behavior redirect secara manual dan timeout 30 detik untuk memberikan cukup waktu bagi proses authentication.

Proses inti dimulai dengan melakukan HTTP POST request ke login URL dengan mengirimkan credentials. Request ini akan mengirim username dan password ke server untuk divalidasi. Setelah mendapatkan response, kita melakukan serangkaian checks yang komprehensif. Pertama, kita check apakah status code adalah 200 (success) atau 302 (redirect) karena kedua status ini umum dalam flow login. Kedua, kita memverifikasi bahwa response mengandung Set-Cookie header yang mengindikasikan session berhasil dibuat. Ketiga, kita check apakah redirect (jika ada) mengarah ke halaman dashboard.

Kita menggunakan custom metric loginFailRate untuk men-track berapa banyak percobaan login yang gagal berdasarkan hasil checks di atas. Jika login berhasil, kita melanjutkan dengan mengakses halaman dashboard menggunakan session cookie yang diterima dari response login. Ini mensimulasikan flow natural user setelah berhasil login - langsung mengakses halaman dashboard. Pada akses dashboard ini, kita kembali melakukan validasi untuk memastikan halaman dapat diakses dengan status 200, mengandung elemen-elemen yang expected seperti kata 'dashboard' atau username, dan halaman terload completely dengan body content yang cukup panjang.

Terakhir, kita menambahkan random sleep antara 1 hingga 3 detik menggunakan Math.random() * 2 + 1. Variasi dalam think time ini mensimulasikan perilaku user nyata yang memiliki kecepatan berbeda-beda dalam berinteraksi dengan sistem setelah login. Pendekatan ini lebih realistic dibandingkan fixed sleep time karena dalam real-world scenario, tidak semua user akan melakukan tindakan berikutnya dalam waktu yang sama persis.

Dengan implementasi performance test untuk login ini, kita dapat mengidentifikasi berbagai potential issues seperti slow database queries pada proses authentication, insufficient session management resources, bottlenecks pada application server, atau masalah-masalah lain yang spesifik terkait proses login concurrent. Data yang dikumpulkan dari test ini akan memberikan insights berharga tentang capacity sistem dalam menangani multiple authentication requests dan membantu tim development dalam optimizing critical path tersebut.

Jadi seperti itu lah implementasi performance testing untuk skenario login bersamaan yang comprehensive dan realistic. Test ini tidak hanya mengukur sekedar HTTP response time tetapi juga memvalidasi entire authentication flow dari mulai login sampai akses halaman terproteksi, memberikan gambaran yang lengkap tentang performance sistem pada scenario yang sangat critical bagi user experience.
